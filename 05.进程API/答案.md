1.编写一个调用fork()的程序。在调用fork()之前，让主进程访问一个变量（例如x）并将其值设置为某个值（例如100）。子进程中的变量有什么值？当子进程和父进程都改变x的值时，变量会发生什么？

fork的核心逻辑在于，他会在父进程调用时返回子进程的pid。而对于被创建的子进程此时返回的值会等于0，从而我们可以通过pid的条件判断来让程序知道自己当前处在哪个进程。

父进程：初始x = 100
父进程：修改后的x = 300
x = 300, pid = 42802
子进程：初始x = 100
子进程：修改后的x = 200
x = 200, pid = 0

2.编写一个打开文件的程序（使用open()系统调用），然后调用fork()创建一个新进程。子进程和父进程都可以访问open()返回的文件描述符吗？当它我并发（即同时）写入文件时，会发生什么？

由于文件符是位于操作系统内的文件系统，因此两个进程都可以访问，但是由于两个进程所指向的偏移量是共享的，所以可能会导致并发问题，从而导致混乱写入。

可以使用wait来控制先后使用的顺序。

3.使用fork()编写另一个程序。子进程应打印“hello”，父进程应打印“goodbye”。你应该尝试我保子进程始终先打印。你能否不在父进程调用wait()而做到这一点呢？

使用管道，通过操作系统内核提供的缓冲区传递数据。

4.编写一个调用fork()的程序，然后调用某种形式的exec()来运行程序/bin/ls。看看是否可以尝试exec()的所有变体，包括execl()、execle()、execlp()、execv()、execvp()和execvP()。为什么同样的基本调用会有这么多变种？

l意味着参数是以连续的方式传入，v意味着参数是以一个args的方式传入，e意味着可以传一个额外的envp的args，p意味着文件是在PATH变量下被找到。

5.现在编写一个程序，在父进程中使用wait()，等待子进程完成。wait()返回什么？如果你在子进程中使用wait()会发生什么？

父进程wait会返回子进程pid，子进程调用wait会返回errno：ECHILD表明当前没有子进程可wait。

6.对前一个程序稍作修改，这次使用waitpid()而不是wait()。什么时候waitpid()会有用？

等待特定的子进程时，waitpid会有用。

7.编写一个创建子进程的程序，然后让子进程中关闭标准输出（STDOUT_FILENO）。如果子进程被关闭描述符后调用printf()打印输出，会发生什么？

如果关闭子进程的标准输出，那么时间线上无论在关闭前或后打印的任何内容，都不会出现在标准输出中。

8.编写一个程序，创建两个子进程，并使用pipe()系统调用，将一个子进程的标准输出连接到另一个子进程的标准输入。

管道运转的核心逻辑在于一个两数组的描述符，其中0表示读端，1则表示写端。对于掌握写端的进程，我们将会关闭他的读端。对于掌握读端的进程，我们将会关闭他的写端。
